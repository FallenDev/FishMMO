using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace FishMMO.Logging
{
	/// <summary>
	/// Manages multiple ILogger implementations, dispatching log entries to all configured loggers.
	/// This acts as the central logging hub for the application.
	/// </summary>
	public static class Log
	{
		private static Dictionary<string, ILogger> loggers;
		private static IConsoleFormatter _consoleFormatter;
		private static IReadOnlyCollection<LogLevel> consoleAllowedLevels;
		private static LoggingConfig currentLoggingConfig; // Stores the currently active configuration

		public static LoggingConfig CurrentLoggingConfig => currentLoggingConfig;

		/// <summary>
		/// Gets a value indicating whether the Log manager has been successfully initialized.
		/// It is considered initialized if the internal 'loggers' list is not null.
		/// </summary>
		public static bool IsInitialized => loggers != null;

		/// <summary>
		/// Gets or sets a value indicating whether timestamps should be included in internal log messages
		/// generated by the Log manager itself (e.g., initialization status, warnings about config).
		/// This also dictates whether timestamps are shown in the UnityConsoleFormatter's output.
		/// Default is true.
		/// </summary>
		public static bool IncludeTimestampsInManagerLogs { get; set; } = true;

		// Flag to indicate if the log manager is in the process of shutting down
		private static volatile bool isShuttingDown = false;

		// Private field to hold the actual internal log message callback provided by the user (or default).
		private static Action<string> _internalLogMessageCallback;

		/// <summary>
		/// Callback for internal logging messages (e.g., initialization status, errors within loggers).
		/// This property's setter wraps the provided action to conditionally add a timestamp
		/// based on the <see cref="IncludeTimestampsInManagerLogs"/> setting.
		/// </summary>
		public static Action<string> OnInternalLogMessage
		{
			get => _internalLogMessageCallback;
			set
			{
				if (value == null)
				{
					// If null is set, revert to the default console writer without timestamp logic
					_internalLogMessageCallback = DefaultInternalLogMessage;
				}
				else
				{
					// Wrap the provided action with timestamp logic
					_internalLogMessageCallback = (message) =>
					{
						string formattedMessage = IncludeTimestampsInManagerLogs ? $"[{DateTime.UtcNow:yyyy-MM-dd HH:mm:ss 'UTC'}] {message}" : message;
						value.Invoke(formattedMessage);
					};
				}
			}
		}

		/// <summary>
		/// The default callback for internal log messages, which writes to System.Console.
		/// This method respects the <see cref="IncludeTimestampsInManagerLogs"/> setting.
		/// </summary>
		/// <param name="message">The message to log internally.</param>
		private static void DefaultInternalLogMessage(string message)
		{
			Console.WriteLine(message);
		}

		// A dictionary mapping ILoggerConfig.Type string to a factory function that creates an ILogger instance.
		// The factory now accepts an Action<string> for internal logger messages.
		private static readonly Dictionary<string, Func<ILoggerConfig, Action<string>, ILogger>> loggerFactories = new Dictionary<string, Func<ILoggerConfig, Action<string>, ILogger>>();

		// Static constructor to ensure loggerFactories dictionary is initialized,
		// but actual registration will happen in Initialize().
		static Log()
		{
			// Initialize the dictionary here
			loggers = new Dictionary<string, ILogger>();

			// Initialize the callback with the default method, which will apply the timestamp wrapping.
			OnInternalLogMessage = DefaultInternalLogMessage;
		}

		/// <summary>
		/// Registers a factory function for creating ILogger instances from ILoggerConfig objects.
		/// </summary>
		/// <param name="configTypeName">The string value of the ILoggerConfig.Type property (e.g., "FileLoggerConfig").</param>
		/// <param name="factory">A function that takes an ILoggerConfig and an Action<string> (for internal logger messages) and returns an ILogger instance.</param>
		public static void RegisterLoggerFactory(string configTypeName, Func<ILoggerConfig, Action<string>, ILogger> factory)
		{
			if (string.IsNullOrWhiteSpace(configTypeName))
			{
				throw new ArgumentNullException(nameof(configTypeName), "Config type name cannot be null or empty.");
			}
			if (factory == null)
			{
				throw new ArgumentNullException(nameof(factory), "Factory function cannot be null.");
			}

			if (loggerFactories.ContainsKey(configTypeName))
			{
				// Now simply invoke the OnInternalLogMessage, as it handles its own timestamping.
				OnInternalLogMessage?.Invoke($"[INTERNAL] WARNING: Logger factory for type '{configTypeName}' is already registered. It will be overwritten.");
			}
			loggerFactories[configTypeName] = factory;
		}

		/// <summary>
		/// Initializes the logging system by loading configuration from a JSON file and setting up loggers.
		/// </summary>
		/// <param name="configPath">The path to the JSON configuration file.</param>
		/// <param name="consoleFormatter">The formatter to use for console output. If null, a default ConsoleFormatter is used.</param>
		/// <param name="preExistingLoggers">Optional: A list of ILogger instances to add directly, bypassing configuration.</param>
		/// <param name="internalLogCallback">Optional: A callback action for internal logging system messages (e.g., errors during initialization). If null, defaults to Console.WriteLine.</param>
		/// <param name="extraLoggerConfigTypes">Optional: Any additional ILoggerConfig types to register with the JSON converter.</param>
		public static async Task Initialize(
			string configPath,
			IConsoleFormatter consoleFormatter = null,
			IEnumerable<ILogger> preExistingLoggers = null,
			Action<string> internalLogCallback = null,
			IEnumerable<Type> extraLoggerConfigTypes = null)
		{
			isShuttingDown = false;

			// Set the internal log callback immediately so all subsequent internal messages use it.
			// The setter will handle the timestamp wrapping.
			if (internalLogCallback != null)
			{
				OnInternalLogMessage = internalLogCallback;
			}
			else
			{
				// Ensure default is re-applied if null is passed, to re-wrap with timestamp logic.
				OnInternalLogMessage = DefaultInternalLogMessage;
			}

			OnInternalLogMessage?.Invoke($"[INTERNAL] Initializing logging manager...");

			currentLoggingConfig = null;
			_consoleFormatter = consoleFormatter ?? new ConsoleFormatter();
			loggers = new Dictionary<string, ILogger>(); // Re-initialize the dictionary for new loggers

			// Add any programmatically supplied loggers first
			if (preExistingLoggers != null)
			{
				foreach (var logger in preExistingLoggers)
				{
					if (logger != null)
					{
						loggers[logger.GetType().Name] = logger;
					}
				}
			}

			// Register built-in logger config types with the ILoggerConfigConverter
			// This is crucial for polymorphic deserialization from JSON.
			ILoggerConfigConverter.RegisterConfigType(typeof(FileLoggerConfig));
			ILoggerConfigConverter.RegisterConfigType(typeof(EmailLoggerConfig));

			// Register built-in logger factories, passing the internal log callback
			RegisterLoggerFactory(nameof(FileLoggerConfig), (cfg, logCallback) => new FileLogger((FileLoggerConfig)cfg, logCallback));
			RegisterLoggerFactory(nameof(EmailLoggerConfig), (cfg, logCallback) => new EmailLogger((EmailLoggerConfig)cfg, logCallback));

			// Register any extra config types provided by the user
			if (extraLoggerConfigTypes != null)
			{
				foreach (var type in extraLoggerConfigTypes)
				{
					try
					{
						ILoggerConfigConverter.RegisterConfigType(type);
						//OnInternalLogMessage?.Invoke($"[INTERNAL] Registered extra logger config type: {type.Name}.");
					}
					catch (ArgumentException ex)
					{
						OnInternalLogMessage?.Invoke($"[INTERNAL] WARNING: Could not register extra logger config type '{type.Name}': {ex.Message}");
						OnInternalLogMessage?.Invoke(ex.ToString()); // Log full exception details
					}
				}
			}

			try
			{
				string jsonString = await File.ReadAllTextAsync(configPath);
				currentLoggingConfig = JsonSerializer.Deserialize<LoggingConfig>(jsonString, new JsonSerializerOptions
				{
					PropertyNameCaseInsensitive = true,
					WriteIndented = true, // For readability in case of debugging serialization
					Converters = { new JsonStringEnumConverter() }
				});

				if (currentLoggingConfig == null)
				{
					OnInternalLogMessage?.Invoke($"[INTERNAL] WARNING: Deserialized LoggingConfig from '{configPath}' is null. No file-based loggers will be configured.");
					// Fallback to default console allowed levels if config is null
					consoleAllowedLevels = new HashSet<LogLevel>(new LoggingManagerConfig().ConsoleAllowedLevels);
					OnInternalLogMessage?.Invoke($"[INTERNAL] Console output levels defaulted to: {string.Join(", ", consoleAllowedLevels)}.");
					return;
				}

				// Set console allowed levels from the loaded configuration
				consoleAllowedLevels = currentLoggingConfig.LoggingManager.ConsoleAllowedLevels;
				OnInternalLogMessage?.Invoke($"[INTERNAL] Console output levels set to: {string.Join(", ", consoleAllowedLevels)}.");

				// Initialize loggers based on the loaded configuration
				foreach (var loggerConfig in currentLoggingConfig.Loggers)
				{
					if (loggerConfig.Enabled)
					{
						if (loggerFactories.TryGetValue(loggerConfig.Type, out var factory))
						{
							try
							{
								if (!loggers.TryGetValue(loggerConfig.LoggerType, out ILogger logger))
								{
									OnInternalLogMessage?.Invoke($"[INTERNAL] INFO: Logger of type '{loggerConfig.LoggerType}' not found...  Adding logger.");

									logger = factory(loggerConfig, OnInternalLogMessage);
									loggers[logger.GetType().Name] = logger;
								}
								else
								{
									OnInternalLogMessage?.Invoke($"[INTERNAL] INFO: Logger of type '{loggerConfig.LoggerType}' found...  Updating configuration.");
								}

								// Pass the internal log callback to the logger's constructor
								logger.SetAllowedLevels(loggerConfig.AllowedLevels);
								logger.SetEnabled(loggerConfig.Enabled);
							}
							catch (Exception ex)
							{
								OnInternalLogMessage?.Invoke($"[INTERNAL] ERROR: Failed to create logger from config type '{loggerConfig.Type}': {ex.Message}");
								OnInternalLogMessage?.Invoke(ex.ToString()); // Log full exception details
							}
						}
						else
						{
							OnInternalLogMessage?.Invoke($"[INTERNAL] WARNING: No logger factory registered for type '{loggerConfig.Type}'. Skipping configuration for this logger.");
						}
					}
					else
					{
						OnInternalLogMessage?.Invoke($"[INTERNAL] INFO: Logger of type '{loggerConfig.Type}' is disabled in configuration. Skipping.");
					}
				}
				OnInternalLogMessage?.Invoke($"[INTERNAL] Logging manager initialized with {loggers.Count} active loggers.");
			}
			catch (FileNotFoundException)
			{
				OnInternalLogMessage?.Invoke($"[INTERNAL] WARNING: Logging configuration file not found at '{configPath}'. No file-based loggers will be configured. Console output will use default levels.");
				PopulateDefaultLoggingConfig(currentLoggingConfig = new LoggingConfig());
				consoleAllowedLevels = new HashSet<LogLevel>(new LoggingManagerConfig().ConsoleAllowedLevels); // Revert to default console levels if config not found
				OnInternalLogMessage?.Invoke($"[INTERNAL] Console output levels defaulted to: {string.Join(", ", consoleAllowedLevels)}.");
			}
			catch (JsonException ex)
			{
				OnInternalLogMessage?.Invoke($"[INTERNAL] ERROR: Failed to parse logging configuration file '{configPath}': {ex.Message}");
				OnInternalLogMessage?.Invoke(ex.ToString()); // Log full exception details
				PopulateDefaultLoggingConfig(currentLoggingConfig = new LoggingConfig());
				consoleAllowedLevels = new HashSet<LogLevel>(new LoggingManagerConfig().ConsoleAllowedLevels); // Revert to default console levels on parse error
				OnInternalLogMessage?.Invoke($"[INTERNAL] Console output levels defaulted to: {string.Join(", ", consoleAllowedLevels)}.");
			}
			catch (Exception ex)
			{
				OnInternalLogMessage?.Invoke($"[INTERNAL] CRITICAL: An unexpected error occurred during logging initialization: {ex.Message}");
				OnInternalLogMessage?.Invoke(ex.ToString()); // Log full exception details
				PopulateDefaultLoggingConfig(currentLoggingConfig = new LoggingConfig());
				consoleAllowedLevels = new HashSet<LogLevel>(new LoggingManagerConfig().ConsoleAllowedLevels); // Revert to default console levels on general error
				OnInternalLogMessage?.Invoke($"[INTERNAL] Console output levels defaulted to: {string.Join(", ", consoleAllowedLevels)}.");
			}
		}

		/// <summary>
		/// Populates the provided LoggingConfig with default instances of all currently registered ILoggerConfig types.
		/// </summary>
		/// <param name="config">The LoggingConfig instance to populate.</param>
		private static void PopulateDefaultLoggingConfig(LoggingConfig config)
		{
			// Clear existing loggers just in case, though a new LoggingConfig should already be empty
			config.Loggers.Clear();

			foreach (var entry in ILoggerConfigConverter.GetAllRegisteredConfigTypes())
			{
				Type configType = entry.Value;
				try
				{
					// Activator.CreateInstance requires a public parameterless constructor.
					// This check is redundant if RegisterConfigType already enforces it, but good for robustness.
					if (configType.IsClass && configType.GetConstructor(Type.EmptyTypes) == null)
					{
						OnInternalLogMessage?.Invoke($"[INTERNAL] WARNING: Skipping automatic inclusion of logger config type '{configType.Name}' because it is a class and lacks a public parameterless constructor. Ensure all ILoggerConfig implementations have one if they are to be auto-populated.");
						continue;
					}

					ILoggerConfig loggerConfig = (ILoggerConfig)Activator.CreateInstance(configType);
					// Set the enabled state to false by default for auto-generated configs,
					// allowing users to explicitly enable them in a new config file.
					loggerConfig.Enabled = false;
					config.Loggers.Add(loggerConfig);
					OnInternalLogMessage?.Invoke($"[INTERNAL] Added default instance of '{configType.Name}' to logging configuration with Enabled = false.");
				}
				catch (Exception ex)
				{
					OnInternalLogMessage?.Invoke($"[INTERNAL] ERROR: Failed to create default instance of logger config type '{configType.Name}': {ex.Message}");
					OnInternalLogMessage?.Invoke(ex.ToString()); // Log full exception details
				}
			}
		}

		/// <summary>
		/// Saves the current logging configuration to a JSON file.
		/// </summary>
		/// <param name="config">The LoggingConfig instance to save.</param>
		/// <param name="filePath">The path to the JSON file where the configuration will be saved.</param>
		public static async Task SaveConfig(LoggingConfig config, string filePath)
		{
			if (config == null)
			{
				OnInternalLogMessage?.Invoke("[INTERNAL] ERROR: Attempted to save a null LoggingConfig.");
				return;
			}

			try
			{
				string jsonString = JsonSerializer.Serialize(config, new JsonSerializerOptions
				{
					WriteIndented = true, // For pretty printing the JSON
					Converters = { new ILoggerConfigConverter(),
								   new JsonStringEnumConverter() },
					ReferenceHandler = ReferenceHandler.IgnoreCycles, // Handle potential circular references if any
				});
				await File.WriteAllTextAsync(filePath, jsonString);

				OnInternalLogMessage?.Invoke($"[INTERNAL] Logging configuration saved to: {filePath}");
			}
			catch (Exception ex)
			{
				OnInternalLogMessage?.Invoke($"[INTERNAL] CRITICAL: Failed to save logging configuration to {filePath}. Exception: {ex}");
			}
		}

		// <summary>
		/// Shuts down the logging system, disposing all active loggers.
		/// This method is asynchronous to allow for potential future async cleanup operations in loggers,
		/// or to be awaited by callers during application shutdown.
		/// </summary>
		public static async Task Shutdown()
		{
			if (loggers == null || isShuttingDown)
			{
				OnInternalLogMessage?.Invoke("[INTERNAL] Log manager not initialized or already shutting down. Skipping shutdown.");
				return;
			}

			isShuttingDown = true; // Set flag to prevent new log writes

			OnInternalLogMessage?.Invoke("[INTERNAL] Initiating log manager shutdown...");

			// Capture current loggers to dispose, then clear the static list
			// to prevent new Log.Write calls from trying to use disposed loggers.
			var loggersToDispose = loggers.Values.ToList(); // Convert to list for iteration
			loggers = null; // Set the dictionary to null to prevent further use

			// If you had a mechanism to track ALL fire-and-forget tasks
			// (e.g., from a modified Log.Write that doesn't await internally),
			// you would await them here to ensure all writes are truly complete.
			// For the current Log.Write implementation, it already awaits its internal
			// ILogger.Log tasks, so by the time a Log.Write call returns, its tasks are done.
			// The async nature of Shutdown() primarily allows *callers* to await it.
			// If individual ILogger implementations have internal queues that need flushing,
			// they would need an internal async method or block within their Dispose() method.

			foreach (var logger in loggersToDispose)
			{
				try
				{
					logger.Dispose(); // Dispose each logger. This is a synchronous call.
									  // If a logger has internal async cleanup, it must block
									  // in its Dispose() or have a separate async method (not defined in ILogger).
				}
				catch (Exception ex)
				{
					OnInternalLogMessage?.Invoke($"[INTERNAL] ERROR: Error disposing logger {logger.GetType().Name}: {ex}");
				}
			}

			_consoleFormatter = null;
			consoleAllowedLevels = null;
			//currentLoggingConfig = null;

			OnInternalLogMessage?.Invoke("[INTERNAL] Log manager shutdown complete.");

			// Return a completed task. If real async cleanup were added to Shutdown(),
			// you would await those tasks here.
			await Task.CompletedTask;
		}

		/// <summary>
		/// Writes a log message with LogLevel.Critical severity.
		/// </summary>
		public static async Task Critical(string source, string message, Exception exception = null, Dictionary<string, object> data = null)
		{
			await Write(LogLevel.Critical, source, message, exception, data);
		}

		/// <summary>
		/// Writes a log message with LogLevel.Error severity.
		/// </summary>
		public static async Task Error(string source, string message, Exception exception = null, Dictionary<string, object> data = null)
		{
			await Write(LogLevel.Error, source, message, exception, data);
		}

		/// <summary>
		/// Writes a log message with LogLevel.Warning severity.
		/// </summary>
		public static async Task Warning(string source, string message, Exception exception = null, Dictionary<string, object> data = null)
		{
			await Write(LogLevel.Warning, source, message, exception, data);
		}

		/// <summary>
		/// Writes a log message with LogLevel.Info severity.
		/// </summary>
		public static async Task Info(string source, string message, Exception exception = null, Dictionary<string, object> data = null)
		{
			await Write(LogLevel.Info, source, message, exception, data);
		}

		/// <summary>
		/// Writes a log message with LogLevel.Debug severity.
		/// </summary>
		public static async Task Debug(string source, string message, Exception exception = null, Dictionary<string, object> data = null)
		{
			await Write(LogLevel.Debug, source, message, exception, data);
		}

		/// <summary>
		/// Writes a log message with LogLevel.Verbose severity.
		/// </summary>
		public static async Task Verbose(string source, string message, Exception exception = null, Dictionary<string, object> data = null)
		{
			await Write(LogLevel.Verbose, source, message, exception, data);
		}

		/// <summary>
		/// Writes a message to the System.Console composed of multiple colored parts using the configured formatter.
		/// This method is for arbitrary colored text, not structured columnar logs.
		/// The message is also dispatched to all registered ILoggers, excluding any logger that declares it handles console parts.
		/// </summary>
		/// <param name="level">The log level for this message (used for indentation/context).</param>
		/// <param name="source">The source of the log message (e.g., "Con soleOutput", "CustomDisplay").</param>
		/// <param name="columnWidth">Optional. The minimum width for each text segment. Text will be padded if shorter.
		/// Use 0 or negative for no padding.</param>
		/// <param name="parts">An array of tuples, where each tuple contains a color (hex or named) and the text for that part.</param>
		public static async Task WritePartsToConsole(LogLevel level, string source, int columnWidth = 0, params (string color, string text)[] parts)
		{
			if (_consoleFormatter == null)
			{
				OnInternalLogMessage?.Invoke($"[INTERNAL] WARNING: Console formatter is null. Cannot write colored parts for level {level}.");
			}
			else if (consoleAllowedLevels == null)
			{
				OnInternalLogMessage?.Invoke($"[INTERNAL] WARNING: Console allowed levels are null. Cannot write colored parts for level {level}.");
			}
			else if (!consoleAllowedLevels.Contains(level))
			{
				OnInternalLogMessage?.Invoke($"[INTERNAL] INFO: Console output for level {level} is not allowed by configuration. Skipping colored parts.");
			}
			else
			{
				_consoleFormatter.WriteColoredParts(level, source, columnWidth, parts);
			}

			// Combine parts into a single string message for other ILoggers
			var sb = new System.Text.StringBuilder();
			foreach (var part in parts)
			{
				sb.Append(part.text);
			}
			string combinedMessage = sb.ToString();

			// Create a LogEntry from the combined message
			var entry = new LogEntry(level, source, combinedMessage, null, null);

			// Dispatch to other loggers asynchronously, filtering by their enabled state and allowed levels.
			var loggingTasks = loggers.Values // Iterate over values of the dictionary
				.Where(logger => logger.IsEnabled &&
								 logger.AllowedLevels.Contains(entry.Level) &&
								 logger.HandlesConsoleParts)
				.Select(logger => logger.Log(entry))
				.ToList();

			await Task.WhenAll(loggingTasks);
		}

		/// <summary>
		/// The primary entry point for all log messages. Dispatches to all configured loggers.
		/// </summary>
		public static async Task Write(LogLevel level, string source, string message, Exception exception = null, Dictionary<string, object> data = null)
		{
			if (loggers == null)
			{
				OnInternalLogMessage?.Invoke($"[INTERNAL] CRITICAL: Log manager not initialized or shut down. Message: {message}");
				return;
			}

			var entry = new LogEntry(level, source, message, exception, data);

			bool consoleHandled = false;

			// Always write to console if enabled and allowed level via the IConsoleFormatter
			if (_consoleFormatter != null && consoleAllowedLevels != null && consoleAllowedLevels.Contains(entry.Level))
			{
				_consoleFormatter.WriteStructuredLog(entry);
				consoleHandled = true;
			}

			// Dispatch to other loggers asynchronously, filtering by their enabled state and allowed levels.
			// If console output was already handled by _consoleFormatter, exclude loggers that specifically handle console parts.
			var loggingTasks = loggers.Values // Iterate over values of the dictionary
				.Where(logger => logger.IsEnabled &&
								 logger.AllowedLevels.Contains(entry.Level) &&
								 (!consoleHandled || logger.HandlesConsoleParts))
				.Select(logger => logger.Log(entry))
				.ToList();

			await Task.WhenAll(loggingTasks);
		}
	}
}