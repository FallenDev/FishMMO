using System;
using System.IO;

namespace FishMMO.Patcher
{

	/// <summary>
	/// Applies binary patch data generated by the PatchGenerator to a target file.
	/// </summary>
	public class Patcher
	{
		// A buffer size for streaming operations. 64KB is a common efficient size.
		private const int StreamBufferSize = 65536;

		/// <summary>
		/// Applies a binary patch from a BinaryReader to a target file.
		/// This method reads patch metadata and applies changes by streaming data
		/// from the original file to a new temporary file, minimizing memory allocation.
		/// It reads patch data from the provided BinaryReader until the end of its underlying stream.
		/// </summary>
		/// <param name="reader">BinaryReader positioned at the start of the patch data for this file.
		/// It is expected that the reader will be fully consumed by this method.</param>
		/// <param name="targetFilePath">The full path to the file to be patched (the "old" file).</param>
		/// <param name="onComplete">Action to invoke when patching is complete (true for success, false for failure).</param>
		public void Apply(BinaryReader reader, string targetFilePath, Action<bool> onComplete)
		{
			// Ensure the target file exists before proceeding
			if (!File.Exists(targetFilePath))
			{
				Console.WriteLine($"Error: Target file not found at '{targetFilePath}'. Cannot apply patch.");
				onComplete?.Invoke(false);
				return;
			}

			string backupFilePath = targetFilePath + ".bak";
			string tempPatchedFilePath = targetFilePath + ".tmp_patched"; // Use a distinct temp file for the output

			// Ensure the directory for the temporary file exists
			string tempDir = Path.GetDirectoryName(tempPatchedFilePath);
			if (!string.IsNullOrEmpty(tempDir) && !Directory.Exists(tempDir))
			{
				Directory.CreateDirectory(tempDir);
			}

			try
			{
				// Make a backup of the old file for roll-back in case of failure
				File.Copy(targetFilePath, backupFilePath, true);
				Console.WriteLine($"Created backup of '{targetFilePath}' at '{backupFilePath}'.");

				// Open the original file for reading and the temporary patched file for writing
				using (FileStream originalFileStream = new FileStream(targetFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
				using (FileStream patchedFileStream = new FileStream(tempPatchedFilePath, FileMode.Create, FileAccess.Write))
				{
					long currentOriginalFilePosition = 0; // Tracks our current read position in the original file

					// Process each patch metadata entry one by one until the end of the stream
					while (reader.BaseStream.Position < reader.BaseStream.Length)
					{
						PatchMetadata patchMetadata = ReadSinglePatchMetadata(reader);

						// 1. Copy the segment of the original file that comes *before* the current patch
						if (patchMetadata.Offset > currentOriginalFilePosition)
						{
							long bytesToCopy = patchMetadata.Offset - currentOriginalFilePosition;
							originalFileStream.Seek(currentOriginalFilePosition, SeekOrigin.Begin); // Ensure correct read position
							CopyStream(originalFileStream, patchedFileStream, bytesToCopy);
						}

						// 2. Write the new bytes from the patch
						if (patchMetadata.NewBytes != null && patchMetadata.NewBytes.Length > 0)
						{
							patchedFileStream.Write(patchMetadata.NewBytes, 0, patchMetadata.NewBytes.Length);
						}

						// 3. Update the current read position in the original file, skipping the 'Length' bytes
						// This effectively moves the conceptual pointer in the original file past the section that was replaced/deleted.
						currentOriginalFilePosition = patchMetadata.Offset + patchMetadata.Length;

						Console.WriteLine($"Applied patch chunk at offset {patchMetadata.Offset}, old length {patchMetadata.Length}, new bytes length {patchMetadata.NewBytes.Length}.");
					}

					// 4. After applying all patches, copy any remaining content from the original file
					// that was after the last patched section.
					if (currentOriginalFilePosition < originalFileStream.Length)
					{
						originalFileStream.Seek(currentOriginalFilePosition, SeekOrigin.Begin); // Ensure correct read position
						CopyStream(originalFileStream, patchedFileStream, originalFileStream.Length - currentOriginalFilePosition);
					}
				} // Streams are automatically closed here

				// Replace the original file with the patched temporary file
				File.Delete(targetFilePath);
				File.Move(tempPatchedFilePath, targetFilePath);

				// Remove the backup if everything was successful
				File.Delete(backupFilePath);
				Console.WriteLine($"Patch applied successfully to '{targetFilePath}'. Backup file '{backupFilePath}' removed.");

				onComplete?.Invoke(true);
			}
			catch (Exception ex)
			{
				Console.WriteLine($"Error applying patch to '{targetFilePath}': {ex.Message}");
				// Restore from backup in case of error
				if (File.Exists(backupFilePath))
				{
					try
					{
						// Ensure the potentially corrupted target file is deleted before restoring
						if (File.Exists(targetFilePath))
						{
							File.Delete(targetFilePath);
						}
						File.Move(backupFilePath, targetFilePath);
						Console.WriteLine($"Restored '{targetFilePath}' from backup due to error. Backup file removed.");
					}
					catch (Exception restoreEx)
					{
						Console.WriteLine($"Critical Error: Failed to restore '{targetFilePath}' from backup: {restoreEx.Message}");
					}
				}
				else
				{
					Console.WriteLine($"Warning: No backup found for '{targetFilePath}'. File may be corrupted.");
				}
				onComplete?.Invoke(false);
			}
			finally
			{
				// Clean up temporary patched file in case of partial failure
				if (File.Exists(tempPatchedFilePath))
				{
					File.Delete(tempPatchedFilePath);
				}
			}
		}

		/// <summary>
		/// Reads a single PatchMetadata entry from the BinaryReader.
		/// This must correctly match the write format of PatchGenerator.
		/// </summary>
		private PatchMetadata ReadSinglePatchMetadata(BinaryReader reader)
		{
			// Read Offset (long)
			long offset = reader.ReadInt64();

			// Read Length (int) - This is the 'Length' of the OLD data replaced, as written by PatchGenerator
			int length = reader.ReadInt32();

			// Read NewBytes.Length (int) - This is the actual length of the new byte array
			int newBytesLength = reader.ReadInt32();

			// Read NewBytes (byte array of 'newBytesLength' size)
			byte[] newBytes = reader.ReadBytes(newBytesLength);

			return new PatchMetadata()
			{
				Offset = offset,
				Length = length,
				NewBytes = newBytes
			};
		}

		/// <summary>
		/// Copies a specified number of bytes from a source stream to a destination stream using a buffer.
		/// </summary>
		/// <param name="source">The source stream to read from.</param>
		/// <param name="destination">The destination stream to write to.</param>
		/// <param name="bytesToCopy">The number of bytes to copy.</param>
		private void CopyStream(Stream source, Stream destination, long bytesToCopy)
		{
			byte[] buffer = new byte[StreamBufferSize];
			long totalBytesRead = 0;
			int bytesRead;

			while (totalBytesRead < bytesToCopy && (bytesRead = source.Read(buffer, 0, (int)Math.Min(buffer.Length, bytesToCopy - totalBytesRead))) > 0)
			{
				destination.Write(buffer, 0, bytesRead);
				totalBytesRead += bytesRead;
			}
		}
	}
}
