namespace FishMMO.Patcher
{
	/// <summary>
	/// Applies binary patch data generated by the PatchGenerator to a target file.
	/// It reads patch metadata from a BinaryReader and reconstructs the new file
	/// by combining parts of the original file with new data from the patch.
	/// This class focuses on creating the patched temporary file;
	/// file deletion and move operations are handled externally.
	/// </summary>
	public class Patcher
	{
		private const int StreamBufferSize = 65536; // Buffer size for streaming operations (64KB).

		/// <summary>
		/// Applies a binary patch from a BinaryReader to a target file,
		/// creating a new temporary file with the patched content.
		/// The responsibility for replacing the original file and cleanup
		/// of the temporary file (by moving it) is left to the caller.
		/// </summary>
		/// <param name="reader">BinaryReader positioned at the start of the patch data for this file.
		/// It is expected that the reader will be fully consumed by this method.</param>
		/// <param name="targetFilePath">The full path to the file to be patched (the "old" file).
		/// This file is only read from; it is not modified or deleted by this method.</param>
		/// <param name="finalFileSize">The expected final size of the file after patching, used for truncation.</param>
		/// <param name="tempPatchedFilePath">The pre-generated unique path for the temporary patched file.</param>
		/// <returns>The full path to the newly created temporary patched file on success; otherwise, null.</returns>
		public string Apply(BinaryReader reader, string targetFilePath, long finalFileSize, string tempPatchedFilePath)
		{
			string normalizedTargetFilePath = Path.GetFullPath(targetFilePath);

			string tempDir = Path.GetDirectoryName(tempPatchedFilePath);
			if (!string.IsNullOrEmpty(tempDir) && !Directory.Exists(tempDir))
			{
				Directory.CreateDirectory(tempDir);
			}

			if (!File.Exists(normalizedTargetFilePath))
			{
				Console.WriteLine($"Error: Target file not found at '{normalizedTargetFilePath}'. Cannot apply patch.");
				try { File.Delete(tempPatchedFilePath); } catch { /* Ignore cleanup errors on early exit */ }
				return null;
			}

			try
			{
				// Ensure the temporary file is empty and ready for writing.
				try { File.Delete(tempPatchedFilePath); } catch { /* Ignore if file doesn't exist or cannot be deleted immediately */ }

				// Create a backup of the original file for rollback.
				string backupFilePath = normalizedTargetFilePath + ".bak";
				try
				{
					Console.WriteLine($"Attempting to create backup of '{normalizedTargetFilePath}' to '{backupFilePath}'.");
					File.Copy(normalizedTargetFilePath, backupFilePath, true); // Overwrite if backup already exists
					Console.WriteLine($"Created backup of '{normalizedTargetFilePath}' at '{backupFilePath}'.");
				}
				catch (Exception ex)
				{
					Console.WriteLine($"Error creating backup for '{normalizedTargetFilePath}': {ex.GetType().Name} - {ex.Message}");

					try { File.Delete(tempPatchedFilePath); } catch { /* Ignore cleanup errors */ }
					return null; // Critical failure, cannot proceed without a valid backup
				}

				// Apply the patch by reading from the original and writing to a temporary file.
				// originalFileStream: Allows other processes to read/write while open.
				// patchedFileStream: Ensures exclusive write access.
				using (FileStream originalFileStream = new FileStream(normalizedTargetFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
				using (FileStream patchedFileStream = new FileStream(tempPatchedFilePath, FileMode.Create, FileAccess.Write, FileShare.None))
				{
					long currentOriginalFilePosition = 0;

					// Read and apply each patch metadata entry until end of stream.
					while (true)
					{
						PatchMetadata patchMetadata;
						try
						{
							patchMetadata = ReadSinglePatchMetadata(reader);
						}
						catch (EndOfStreamException)
						{
							break; // All patch metadata has been read.
						}
						catch (Exception ex)
						{
							Console.WriteLine($"Error reading patch metadata for '{normalizedTargetFilePath}': {ex.Message}");
							throw; // Re-throw to be caught by the outer try-catch
						}

						// Copy unchanged segments from the original file.
						if (patchMetadata.Offset > currentOriginalFilePosition)
						{
							long bytesToCopy = patchMetadata.Offset - currentOriginalFilePosition;
							originalFileStream.Seek(currentOriginalFilePosition, SeekOrigin.Begin);
							CopyStream(originalFileStream, patchedFileStream, bytesToCopy);
						}

						// Write new bytes from the patch data.
						if (patchMetadata.NewBytes?.Length > 0)
						{
							patchedFileStream.Write(patchMetadata.NewBytes, 0, patchMetadata.NewBytes.Length);
						}

						// Advance tracking position in the original file.
						currentOriginalFilePosition = patchMetadata.Offset + patchMetadata.Length;
					}

					// Copy any remaining content from the original file after the last patch.
					if (currentOriginalFilePosition < originalFileStream.Length)
					{
						originalFileStream.Seek(currentOriginalFilePosition, SeekOrigin.Begin);
						CopyStream(originalFileStream, patchedFileStream, originalFileStream.Length - currentOriginalFilePosition);
					}

					// Truncate/Extend the patched file to its final expected size.
					if (finalFileSize >= 0)
					{
						if (patchedFileStream.Length > finalFileSize)
						{
							patchedFileStream.SetLength(finalFileSize);
							Console.WriteLine($"Truncated patched file to final size {finalFileSize} bytes.");
						}
						else if (patchedFileStream.Length < finalFileSize)
						{
							Console.WriteLine($"Warning: Patched file length ({patchedFileStream.Length}) is less than expected final size ({finalFileSize}). Extending with zeros. This will likely cause a hash mismatch.");
							patchedFileStream.SetLength(finalFileSize);
						}
					}
					else
					{
						Console.WriteLine("Warning: Invalid final file size provided. File length will be determined by applied patches.");
					}
				} // Streams are closed here, handles released.

				Console.WriteLine($"Successfully created temporary patched file: '{tempPatchedFilePath}'.");
				return tempPatchedFilePath; // Return the path for external finalization
			}
			catch (Exception ex) // Handles errors during temporary file creation.
			{
				Console.WriteLine($"Error creating temporary patched file for '{normalizedTargetFilePath}': {ex.GetType().Name} - {ex.Message}");

				// Clean up the temporary file if an error occurred.
				try
				{
					if (File.Exists(tempPatchedFilePath))
					{
						File.Delete(tempPatchedFilePath);
						Console.WriteLine($"Cleaned up temporary file '{tempPatchedFilePath}' due to error.");
					}
				}
				catch (Exception cleanupEx)
				{
					Console.WriteLine($"Warning: Failed to delete temporary file '{tempPatchedFilePath}' during error cleanup: {cleanupEx.Message}");
				}
				return null; // Signal failure
			}
		}

		/// <summary>
		/// Reads a single <see cref="PatchMetadata"/> entry from the provided <see cref="BinaryReader"/>.
		/// Assumes data is written in the format: Offset (long), Length (int), NewBytes.Length (int), NewBytes (byte[]).
		/// </summary>
		/// <param name="reader">The <see cref="BinaryReader"/> to read from.</param>
		/// <returns>A <see cref="PatchMetadata"/> object populated with the read data.</returns>
		/// <exception cref="EndOfStreamException">Thrown if the end of the stream is reached unexpectedly.</exception>
		private PatchMetadata ReadSinglePatchMetadata(BinaryReader reader)
		{
			long offset = reader.ReadInt64();
			int length = reader.ReadInt32();
			int newBytesLength = reader.ReadInt32();
			byte[] newBytes = reader.ReadBytes(newBytesLength);

			if (newBytes.Length != newBytesLength)
			{
				throw new EndOfStreamException($"Expected {newBytesLength} bytes for NewBytes, but only read {newBytes.Length}. Patch data might be truncated or corrupted.");
			}

			return new PatchMetadata()
			{
				Offset = offset,
				Length = length,
				NewBytes = newBytes
			};
		}

		/// <summary>
		/// Copies a specified number of bytes from a source stream to a destination stream using a buffer.
		/// </summary>
		/// <param name="source">The source <see cref="Stream"/> to read from.</param>
		/// <param name="destination">The destination <see cref="Stream"/> to write to.</param>
		/// <param name="bytesToCopy">The total number of bytes to copy.</param>
		private void CopyStream(Stream source, Stream destination, long bytesToCopy)
		{
			byte[] buffer = new byte[StreamBufferSize];
			long totalBytesRead = 0;
			int bytesRead;

			while (totalBytesRead < bytesToCopy &&
				   (bytesRead = source.Read(buffer, 0, (int)Math.Min(buffer.Length, bytesToCopy - totalBytesRead))) > 0)
			{
				destination.Write(buffer, 0, bytesRead);
				totalBytesRead += bytesRead;
			}
		}
	}
}